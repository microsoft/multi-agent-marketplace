"""Log-related routes."""

from datetime import UTC, datetime

from fastapi import APIRouter, HTTPException, Query, Request

from ...database.base import DatabaseTooBusyError
from ...database.models import LogRow
from ...database.queries.base import RangeQueryParams
from ...shared.models import (
    BaseResponse,
    LogCreateRequest,
    LogListResponse,
)
from ..server import get_database

router = APIRouter(prefix="/logs", tags=["logs"])


@router.post("/create", response_model=BaseResponse)
async def create_log(
    request: LogCreateRequest, fastapi_request: Request
) -> BaseResponse:
    """Create a log record."""
    db = get_database(fastapi_request)

    try:
        db_log_record = LogRow(
            id="",  # Will be generated by database
            created_at=datetime.now(UTC),
            data=request.log,
        )
        await db.logs.create(db_log_record)
        return BaseResponse()
    except DatabaseTooBusyError as e:
        raise HTTPException(
            status_code=429, detail=f"Database too busy: {e.message}"
        ) from e
    except Exception as e:
        return BaseResponse(error=str(e))


@router.get("", response_model=LogListResponse)
async def get_logs(
    fastapi_request: Request,
    after: str | None = Query(
        None, description="Logs after this timestamp (ISO format)"
    ),
    before: str | None = Query(
        None, description="Logs before this timestamp (ISO format)"
    ),
    offset: int = Query(0, ge=0),
    limit: int | None = Query(None, ge=1),
) -> LogListResponse:
    """Get log records with optional filtering."""
    db = get_database(fastapi_request)

    try:
        query_params = RangeQueryParams(offset=offset, limit=limit)

        if after or before:
            range_params = RangeQueryParams(
                offset=offset,
                limit=limit,
                after=after,  # type: ignore Pydantic correctly handles this.
                before=before,  # type: ignore Pydantic correctly handles this.
            )
            db_logs = await db.logs.get_all(range_params)
        else:
            db_logs = await db.logs.get_all(query_params)

        total = await db.logs.count()
        has_more = limit is not None and len(db_logs) == limit

        # Extract logs from db logs
        logs = [db_log.data for db_log in db_logs]

        return LogListResponse(
            items=logs, total=total, offset=offset, limit=limit, has_more=has_more
        )
    except DatabaseTooBusyError as e:
        raise HTTPException(
            status_code=429, detail=f"Database too busy: {e.message}"
        ) from e
